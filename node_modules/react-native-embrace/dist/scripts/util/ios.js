"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const glob = require('glob');
const xcode = require('xcode');
const fs = require('fs');
const file_1 = require("./file");
const logger_1 = require("../../src/logger");
const embLogger = new logger_1.default(console);
exports.embraceNativePod = `
  pod 'EmbraceIO'
`;
exports.embraceImport = `
#import <Embrace/Embrace.h>
`;
exports.bundlePhaseRE = /react-native-xcode\.sh/;
exports.bundlePhaseExtraArgs = 'export EXTRA_PACKAGER_ARGS="--sourcemap-output $CONFIGURATION_BUILD_DIR/$UNLOCALIZED_RESOURCES_FOLDER_PATH/main.jsbundle.map"';
exports.embRunScript = '"${PODS_ROOT}/EmbraceIO/run.sh"';
exports.appDelegatePatchable = ({ name }) => {
    return new Promise((resolve, reject) => {
        const appDelegatePath = glob.sync('**/AppDelegate.m', { ignore: 'node_modules/**' }).find((path) => path.indexOf(name) > -1);
        if (!appDelegatePath) {
            return reject(embLogger.format('Couldn\'t find AppDelegate. Please refer to the docs at https://docs.embrace.io to update manually.'));
        }
        const appDelegate = file_1.getFileContents(appDelegatePath);
        return resolve(appDelegate);
    });
};
exports.podfilePatchable = () => {
    return new Promise((resolve, reject) => {
        const podfilePath = glob.sync('ios/Podfile')[0];
        if (!podfilePath) {
            return reject(embLogger.format('Could not find Podfile. Please refer to the docs at https://docs.embrace.io to update manually.'));
        }
        const podfile = file_1.getFileContents(podfilePath);
        return resolve(podfile);
    });
};
exports.embracePlistPatchable = ({ name }) => {
    return new Promise((resolve, reject) => {
        const plistPath = glob.sync('ios/**/Embrace-Info.plist')[0];
        if (!plistPath) {
            return reject(embLogger.format('Could not find Embrace-Info.plist'));
        }
        return resolve(file_1.getFileContents(plistPath));
    });
};
exports.xcodePatchable = ({ name }) => {
    return new Promise((resolve, reject) => {
        const projectPath = glob
            .sync('**/*.xcodeproj/project.pbxproj', { ignore: 'node_modules/**' })
            .find((path) => path.indexOf(name) > -1);
        if (!projectPath) {
            return reject(embLogger.format(`Could not find xcode project file. ${docsMessage}`));
        }
        return getXcodeProject(projectPath).then(resolve);
    });
};
const docsMessage = 'Please refer to the docs at https://docs.embrace.io to update manually.';
const getXcodeProject = (path) => {
    const project = xcode.project(path);
    return new Promise((resolve, reject) => {
        project.parse((err) => {
            if (err) {
                return reject(err);
            }
            const proj = new XcodeProject(path, project);
            resolve(proj);
        });
    });
};
class XcodeProject {
    constructor(path = '', project) {
        this.path = path;
        this.project = project;
    }
    buildPhaseObj() {
        return this.project.hash.project.objects.PBXShellScriptBuildPhase || {};
    }
    hasLine(key, line) {
        const buildPhaseObj = this.buildPhaseObj();
        const phase = buildPhaseObj[key];
        if (!phase) {
            return false;
        }
        if (!phase.shellScript) {
            return false;
        }
        const code = JSON.parse(phase.shellScript);
        return (line instanceof RegExp ? code.search(line) : code.indexOf(line)) > -1;
    }
    modifyPhase(key, line, add) {
        // Doesn't include line
        if (!this.hasLine(key, line)) {
            return;
        }
        // Already has add
        if (add && this.hasLine(key, add)) {
            return;
        }
        const buildPhaseObj = this.buildPhaseObj();
        const phase = buildPhaseObj[key];
        if (!phase) {
            return;
        }
        if (!phase.shellScript) {
            return;
        }
        let code = JSON.parse(phase.shellScript);
        code = code.replace(line, (match) => `${add}${add === '' ? '' : match}`);
        phase.shellScript = JSON.stringify(code);
    }
    findPhase(line) {
        const buildPhaseObj = this.buildPhaseObj();
        return Object.keys(buildPhaseObj).find((key) => {
            return this.hasLine(key, line);
        }) || '';
    }
    findAndRemovePhase(line) {
        const buildPhaseObj = this.buildPhaseObj();
        this.project.hash.project.objects.PBXShellScriptBuildPhase = Object.keys(buildPhaseObj).reduce((a, key) => {
            const phase = buildPhaseObj[key];
            if (!phase) {
                return a;
            }
            if (phase.shellScript) {
                const code = JSON.parse(phase.shellScript);
                if (code.search(line) > -1) {
                    return a;
                }
            }
            return Object.assign(Object.assign({}, a), { [key]: buildPhaseObj[key] });
        }, {});
    }
    sync() {
        this.project = this.project.writeSync();
    }
    patch() {
        fs.writeFileSync(this.path, this.project);
    }
    addFile(groupName, path) {
        const target = this.findHash(this.project.hash.project.objects.PBXNativeTarget, groupName);
        const group = this.findHash(this.project.hash.project.objects.PBXGroup, groupName);
        if (target && group) {
            const file = this.project.addFile(path, group[0], { target: target[0] });
            file.target = target[0];
            file.uuid = this.project.generateUuid();
            this.project.addToPbxBuildFileSection(file);
            this.project.addToPbxResourcesBuildPhase(file);
        }
    }
    findHash(objects, groupName) {
        return Object.entries(objects).find(([_, group]) => {
            return group.name === groupName;
        });
    }
}
exports.formatEmbraceInitializer = (appID) => `
  [[Embrace sharedInstance] startWithKey:@"${appID}" launchOptions:launchOptions framework:EMBAppFrameworkReactNative];
`;
